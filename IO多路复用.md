# I/O多路复用

I/O多路复用是指内核发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。

![1562485833616](C:\Users\king return\Desktop\IO multiplexed select\picture\IO多路复用.png)

**引入I/O多路复用的意义：**相对于传统的多进程并发模型（每进来一个新的I/O流会分配一个新的进程管理），这样做效率低下，而I/O多路复用，利用**单个线程**，通过记录跟踪每个I/O流（sock）的状态，来同时管理多个I/O流，尽量的提高服务器的吞吐能力

与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

**I/O多路复用适用的场合：**

1. 当客户处理多个描述字时（一般是交互式输入和网络套接字），**必须**使用I/O复用
2. 当一个客户同时处理多个套接口时，而这种情况是可能的，但是很少出现
3. 如果一个TCP服务器既要处理监听套接口，又要处理以连接套接口，一般也要用到I/O复用
4. 如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用
5. 如果一个服务器要处理多个服务或者多个协议，一般要使用I/O复用

**select和poll以及epoll都是I/O多路复用的具体的实现**

select是第一个实现的（1983左右在BSD里面实现的），主要存在以下问题：

- select会修改传入的参数数组，这个对于一个需要调用很多次的函数是非常不友好的

- select如果任何一个sock（I/O stream）出现数据，select仅仅会返回，但是并不会告诉你是那个sock上有数据，于是你只能自己一个一个的找，几十个数量级的sock可能还好，但是要是上升到几万的sock每次都查找一遍，开销就会相当的大
- select只能监视1024个连接
- select不是线程安全的，如果你把一个sock加入到select，然后突然另外一个线程发现，这个sock不用，要收回。这个在select是不支持的，如果你要伤心病狂的关掉这个sock，select的标准是不可预测（“If a file descriptor being monitored by select() is closed in another thread, the result is unspecified”），文档就是这么霸气

poll是在14年后1997年由一帮人实现的，poll修复了select的很多问题，比如：

- poll去掉了1024个连接的限制，上限是多少呢，emmm，主人你开心就行
- poll从设计上来说，不再修改传入数组，不过这个要看你的平台，姓周江湖，小心为好

**其实拖14年那么久也不是效率问题， 而是那个时代的硬件实在太弱，一台服务器处理1千多个链接简直就是神一样的存在了，select很长段时间已经满足需求。**

但是poll仍然不是线程安全的，这就意味着，不管服务器有多强悍，你也只能在一个线程里面处理一组I/O流。当然你也可以拿多进程来配合，不过然后你就有了多进程的各种问题

于是5年以后，在2002年，大神Davide实现了epoll，epoll可以说是I/O多路复用最新的一个实现，epoll修复了poll和select绝大部分问题，比如：

- epoll现在是线程安全的
- epoll现在不仅告诉你sock组里面数据，还会具体告诉你具体那个sock有数据，你不用自己去找了（区别与select的轮询方式）。

但是**epoll**有个致命的缺点，那就是**只有linux支持**

*PS: 上面所有这些比较分析，都建立在大并发下面，如果你的并发数太少，用哪个，其实都没有区别。*



